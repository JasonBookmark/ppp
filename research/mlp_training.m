function mlp_training()

root_dir = 'mugshot_frontal_original_all';
img_files = dir([root_dir '/*.jpg']);
pos_files = dir([root_dir '/*.pos']);
ann_files = dir([root_dir '/*.ann']);

do_display = 0; % Don't display annotations

num_faces = length(pos_files);
image_indices = 1:num_faces;
%image_indices = [98];

% Derived measures
pupil_separ = zeros(num_faces,1); % Distance between the eye pupils
mouth_width = zeros(num_faces,1); % Mouth width (left lip to right lip corner)
frown_mouth = zeros(num_faces,1); % Distance from the frown point to the center of the mouth
crown_frown = zeros(num_faces,1); % Distance from crown point to frown point

chin_crown = zeros(num_faces,1); % Distance from chin to crown
chin_frown = zeros(num_faces,1); % Distance from face center to frown

for k=1:length(image_indices),    
    i=image_indices(k);
    lm = load([root_dir '/' pos_files(i).name]);    
    
    pupil_separ(i) = distancelm(lm, 7, 10);
    mouth_width(i) = distancelm(lm, 15, 16);
    
    frownx = (lm(7,1)+lm(10,1))/2;
    frowny = (lm(7,2)+lm(10,2))/2;

    mouthx = (lm(15,1)+lm(16,1))/2;
    mouthy = (lm(15,2)+lm(16,2))/2;

    frown_mouth(i) = distance(frownx, frowny, mouthx, mouthy);
    
    crown_frown(i) = distance(frownx, frowny, lm(1,1), lm(1,2));

    [crownx, crowny] = closest_point(frownx, frowny, mouthx, mouthy, lm(1,1), lm(1,2));
    [chinx, chiny] = closest_point(frownx, frowny, mouthx, mouthy, lm(17,1), lm(17,2));
    
    chin_crown(i) = distance(crownx, crowny, chinx, chiny);

    chin_frown(i) = distance(frownx, frowny, chinx, chiny);

    if (do_display)
        img = imread([root_dir '/' img_files(i).name]);
        imshow(img);
        hold on
        pp = lm([1,17, 7, 10],:);
        scatter(pp(:,1), pp(:,2));
        scatter(rm([5,7, 9, 11, 13, 15]), rm([6,8, 10, 12, 14, 16]), 'x');
        rectangle('Position', rm(1:4))
        hold off
    end
end
close all;

normalis = 1;% frown_mouth + pupil_separ;
inputs = [pupil_separ./normalis  frown_mouth./normalis  mouth_width./normalis];

output_c1 = chin_crown./normalis;
output_c2 = chin_frown./normalis;
iiss = frown_mouth + pupil_separ;

c1 = mean(chin_crown./iiss);
c2 = mean(chin_frown./iiss);

output_c3 = chin_frown./chin_crown;
c3 = mean(output_c3);


output_c2_prime = iiss *c2; 
output_c1_prime = iiss *c1;
rrc1 = corrcoef(output_c1, output_c1_prime);
rrc2 = corrcoef(output_c2, output_c2_prime);


output_c3_prime = chin_crown*c3;
rrc3 = corrcoef(crown_frown, output_c3_prime);



%scatter(outputs, outputss);
r = zeros(1, 20);
for i = 1:20,
    [net, ~, ~] = train1(inputs', outputs');
    output1 = net(inputs');
    rr = corrcoef(outputs', output1);
   % scatter(outputs', output1)
    r(i) = rr(1,2);
end
median(r)

% outputs1 = myNeuralNetworkFunction(inputs);
% scatter(outputs(:,2), outputs1(:,2))
end

function [x,y,dp, dc]=closest_point_perpendicular(x1,y1,x2,y2,xp,yp)
x0=(x1+x2)/2;
y0=(y1+y2)/2;

a = (x1-x2);
b = (y1-y2);
c = y0*(y2-y1)+x0*(x2-x1);
a2b2 = a*a+b*b;

x = (b*(b*xp-a*yp) - a*c)/a2b2;
y = (a*(-b*xp + a*yp)-b*c)/a2b2;
dp = distance(x,y,xp,yp);
dc = distance(x,y,x0,y0);
end

function [x,y,dp] = closest_point(ax, ay, bx, by, px, py)
a_to_px = px - ax;
a_to_py = py - ay;  
a_to_bx = bx - ax;
a_to_by = by - ay; 
atb2 = a_to_bx * a_to_bx + a_to_by * a_to_by;

atp_dot_atb = a_to_px * a_to_bx + a_to_py * a_to_by;
t = atp_dot_atb / atb2;  
x = ax + a_to_bx * t;
y = ay + a_to_by * t;
dp = distance(x,y, px, py);
end 

function d = distance(x1 ,y1, x2, y2)
d = sqrt((x1-x2).^2 + (y1-y2).^2);
end

function d = distancelm(lm, a, b)
d = distance(lm(a,1), lm(a,2),lm(b,1), lm(b,2));  
end

function [y1] = myNeuralNetworkFunction(x1)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 28-Feb-2016 17:36:51.
%
% [y1] = myNeuralNetworkFunction(x1) takes these arguments:
%   x = Qx3 matrix, input #1
% and returns:
%   y = Qx2 matrix, output #1
% where Q is the number of samples.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1_xoffset = [0.4429655968571;0.47347865593734;0.294557500995072];
x1_step1_gain = [23.9361153108916;23.9361153108916;7.59037972932776];
x1_step1_ymin = -1;

% Layer 1
b1 = [2.5061440768303429;1.3103742956436844;0.67938044910427453;-0.25942542103421534;1.1816587790836734;2.05399355198881];
IW1_1 = [-1.2363961913307355 0.35800621419490619 -2.2191078191549365;-0.12430156280807157 -2.3159557797628869 -1.5328037051417176;-2.9490100890876185 -0.41729192002339377 0.97383928974463174;-3.0652152227538112 0.21173960369958128 1.07478009438123;1.9870150609403368 1.4432455569588152 1.1943109469280544;1.9987441592737381 -2.107249393295727 0.46709291514843809];

% Layer 2
b2 = [-0.47829043985865494;0.21752655740715363];
LW2_1 = [-0.23278145896065217 0.14577050302914257 1.0844981767440898 -1.3314551114579565 0.97837710003144895 -1.0596552563034201;0.17647057263858665 -0.94105508746424715 -0.17073145672637507 0.027567192335154294 -0.42351946542304186 0.35736410453024725];

% Output 1
y1_step1_ymin = -1;
y1_step1_gain = [4.40019945499671;15.0012128340313];
y1_step1_xoffset = [1.55545746309382;8.26951714978958e-08];

% ===== SIMULATION ========

% Dimensions
Q = size(x1,1); % samples

% Input 1
x1 = x1';
xp1 = mapminmax_apply(x1,x1_step1_gain,x1_step1_xoffset,x1_step1_ymin);

% Layer 1
a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*xp1);

% Layer 2
a2 = repmat(b2,1,Q) + LW2_1*a1;

% Output 1
y1 = mapminmax_reverse(a2,y1_step1_gain,y1_step1_xoffset,y1_step1_ymin);
y1 = y1';
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings_gain,settings_xoffset,settings_ymin)
y = bsxfun(@minus,x,settings_xoffset);
y = bsxfun(@times,y,settings_gain);
y = bsxfun(@plus,y,settings_ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings_gain,settings_xoffset,settings_ymin)
x = bsxfun(@minus,y,settings_ymin);
x = bsxfun(@rdivide,x,settings_gain);
x = bsxfun(@plus,x,settings_xoffset);
end


function [net, errors, performance] = train1(inputs, targets)
% Create a Fitting Network
hiddenLayerSize = 6;
net = fitnet(hiddenLayerSize);

% Set up Division of Data for Training, Validation, Testing
net.divideParam.trainRatio = 80/100;
net.divideParam.valRatio = 10/100;
net.divideParam.testRatio = 10/100;
 
% Train the Network
[net,tr] = train(net,inputs,targets);
 
% Test the Network
outputs = net(inputs);
errors = gsubtract(outputs,targets);
performance = perform(net,targets,outputs)
end